---
title: git aliae so that you never lose work (part 2)
permalink: blog/git-aliae-2.html
layout: post
fuzzydate: May 2012
---

Git is an incredibly powerful tool for version control. Much of this power stems
from its underlying append-only object database which ensures that once
you've made a commit it can never be changed or unmade.

This doesn't sound great on the surface because [as described
before](http://cirw.in/blog/git-aliae-1) it's really nice to be able to clean
your commits as you go. What's interesting is that in reality the append-only
model actually encourages rewriting history, because if anything goes wrong, you
can always `git reset` back to your original set of commits.

Making mistakes is something that everyone does, and it's nice that git in some
areas provides a strong safety net. It has annoyed me for a while however that
git doesn't provide a similar safety net when dealing with changes that haven't
yet been committed.

Naming and Shaming
------------------

There are three git commands you really need to watch out for; and if you've
used git for a sufficient length of time I guarantee that they'll have bitten
you:

1. `git checkout` (with `-f`, or with a filename)
2. `git reset --hard`
3. `git clean -f`

If you're spotting patterns, you'll notice that these three commands are similar
in many ways. Importantly they all have the power to clean up your working
directory, and unfortunately none of them supports an undo operation.

Luckily, git makes it pretty to add support for undo to any command that changes
your working directory. All you need to do is wrap the command in such a way
that it saves the current state of your file-system into the object database
before changing it. As mentioned before, once something is in the object
database, it can't be changed or removed.

<aside>Uner the hood: In order that the size of your repository doesn't grow
unboundedly git actually does garbage collection on the object database. This
will delete unused things (like backups) which are over two weeks old.</aside>

git-cof && git-foc
------------------

The [git aliae](https://github.com/ConradIrwin/git-aliae) that I've written
which do this are `git cof` (which wraps `git checkout -f`) and `git foc` which
automates the undo step.

`git cof` can be used as a drop-in replacement for all use of `git checkout`,
excepting `-m` which is supposed to preserve changes, and `-p` which gives you
more control. Because it's easy to get your changes back you don't have to be
shy about using the `-f` flag where you normally wouldn't.

`git foc` is a wrapper that gives you back your changes. This is designed to be
used shortly after a `git cof`, the longer you delay before running this, the
higher the chances are that it will merge-conflict with new changes that you've
made.

<aside>caveat emptor: `git cof` only saves one change in a form that is
identifiable by `git foc`. Older backups of the working tree are retrievable,
though you will have to do this manually. Use `tail .git/tree_backups` to get
the list of commit ids for recent backups, and then use normal git tools to
extract the changes that you want to reinstate.</aside>

git reset --keep
----------------

In git version 1.7.1 a new flag was added to `git reset`. The `--keep` flag is
designed to do exactly the same as `--hard`; but if you have uncommitted
changes, it keeps them instead of discarding them.

Concretely that means that it makes your current branch point to the commit you
specify, and then it re-applies all of your uncommitted changes. If it can't do
this properly, then it will do nothing and tell you that it's doing nothing.

This means that there's now no reason to use `git reset --hard` ever. You can
always use `git reset --keep`. In the rare cases that it aborts because you have
uncommitted changes that conflict with the reset, you can always use `git cof`
to throw away your local changes in a safe way, and then retry.

<aside>If your version of git is too old, it's actually very easy to upgrade.
See [the git website](http://git-scm.com/) for details.</aside>

Preserving untracked files
--------------------------

One thing that `git-cof` doesn't do is preserve files that are untracked (i.e.
you haven't yet `git add`ed them. This was recommended to me by the
[#git](irc://irc.freenode.net) IRC channel as being a useful precaution to avoid
bloating the size of the object database unexpectedly; and is consistent with
most git commands that do not touch untracked files.

This means that `git cof` doesn't really help with `git clean -f` yet. Even so
I'd recommend not using `git clean` at all. I tend to manually use `rm` when I
want to clean up the repository because copy-and-pasting a filename gives me
time to think about each file individually before I consign it to permanent
death.

Summary
-------

Internalising two things can help you avoid losing most work with git:

1. Use `git cof` instead of `git checkout`
2. Use `git reset --keep` instead of `git reset --hard`.

I've found both have saved me a considerable amount of time that would otherwise
be wasted re-writing lost code.

To install `git cof` and `git foc`, you need to `git clone
https://github.com/ConradIrwin/git-aliae` and then add `export
PATH=$PATH:/path/to/git-aliae/bin` to your `~.bashrc`. Please report bugs and
feature requests to [GitHub issues](https://github.com/ConradIrwin/git-aliae/issues).

<aside>If you've already installed the git aliae mentioned in [part
one](http://cirw.in/blog/git-aliae-1) of this series. You can just `git pull` to get the
latest changes. See the [README](https://github.com/ConradIrwin/git-aliae) for more.</aside>
