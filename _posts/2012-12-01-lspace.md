---
title: "LSpace: Dynamic scope for Ruby"
permalink: blog/lspace.html
layout: post
fuzzydate: December 2012
---

Over the last week or two I've been working on an exciting new library:
[LSpace](https://github.com/ConradIrwin/lspace).

At its simplest, LSpace is an update to Ruby's thread-local variables to bring
them kicking and screaming into the 202nd decade:

1. LSpace locals are changed only for the duration of a block. This means that
   you won't permanently clobber the value that someone else set, and that your
   value won't leak once you no-longer need it.
2. LSpace can automatically extend the notion of thread when you're using
   [eventmachine](https://github.com/eventmachine/eventmachine) or
   [celluloid](http://celluloid.io). Values in LSpace are preserved even when your code
   jumps between actors or continues after a callback.

As I'm sure the old-time-lispers are eager to point out, the first makes
LSpace an implementation of
[dynamic scoping](http://en.wikipedia.org/wiki/Dynamic_scope#Lexical_scoping_and_dynamic_scoping)
and the second exists to avoid the confusion caused by the
[upwards funarg problem](http://en.wikipedia.org/wiki/Funarg_problem#Upwards_funarg_problem).

What's it good for?
===================

LSpace is for storing secondary data about your program. For example, if you
want to make sure a string is always included in log output, you can add it to
LSpace:

{% highlight ruby %}
def log(str)
  puts "#{LSpace[:log_prefix]}: #{str}"
end

LSpace.with(:log_prefix => "example") do
  log "hello world"
end
# => example: hello world
{% endhighlight %}

I could have just passed `log_prefix` into the log method directly, but I chose not to in
order to keep the API clean. The benefits of this become more obvious in a larger example:

{% highlight ruby %}
def fetch(url)
  url = URI(url)
  log "Fetching #{url}"
  Net::HTTP.get(url)
end

def get_title(url)
  html = fetch(url)
  (Nokogiri::HTML(html) / 'title').to_s
end

LSpace.with(:log_prefix => "example") do
  get_title 'http://www.google.com'
end
{% endhighlight %}

If I didn't have LSpace (or thread locals) then I'd have had to pass
`log_prefix` as an argument to `get_title`. This works, but it's ugly:

{% highlight ruby %}
def get_title(url, log_prefix)
  html = fetch(url, log_prefix)
  (Nokogiri::HTML(html) / 'title').to_s
end
{% endhighlight %}

I don't just mean "it's ugly because it now takes two parameters", though that
certainly doesn't help. It's ugly because `get_title` shouldn't depend on how
`fetch` is implemented; in fact, `fetch` shouldn't even depend on how the logger
is implemented.

This tight coupling means that if I ever want to change the logger so that it
doesn't need a prefix, or perhaps it needs a suffix too, I'm going to have to
change a lot of code. It also means that if I want to introduce a new log call,
I'm going to have to pass `log_prefix` through an entirely new call-stack.

In general, if a small change would require large code changes, you're not going to have
much fun maintaining your code. LSpace provides a useful tool to help you keep your
application manageable in cases like this.

Should I use LSpace?
====================

LSpace makes part of your context implicit. This is good because it reduces the amount of
state-passing you need to do, but also bad because there's nothing to remind programmers
to set the state up correctly. In general LSpace works well for things that don't really
affect what your program does, just tweak the manner in which it does them.

For example, we're using this technique for:

1. Setting a logging prefix (just like in the example above). It makes logs much
   easier to read when you can associate lines that came from the same request.
2. Being able to use a particular database connection for the duration of a
   block. When we show the user their own information, we force the code to read
   from our master database so that any changes they just made will appear.
3. Maintaining state in our metrics library to enable
   [Zipkin](http://twitter.github.com/zipkin/)-style traces of which slownesses
   are caused by which others.

Other people are using similar ideas for some really cool stuff. In particular
you should look at how the reactive programming is implemented in
[meteor.js](http://docs.meteor.com/#reactivity), or why dynamic scope is used in
[Emacs lisp](http://www.gnu.org/software/emacs/emacs-paper.html#SEC18).

What else can it do?
====================

It turns out that the magic LSpace needs to implement dynamic closures (i.e.,
the magic that lets it extend thread-local variables across eventmachine
callbacks or celluloid actor calls) is pretty useful for applications too.

If you're interested in doing something similar, you can add an `around_filter`
using LSpace, and it will ensure that whenever the LSpace is re-activated, the
code is wrapped by your block.

We use this for integrating with log4r (which has support for thread-locals, but
not LSpace) and also for implementing a fallback exception handler in
eventmachine:

{% highlight ruby %}
LSpace.around_filter do |&block|
  begin
    block.call
  rescue => e
    puts "Job #{job_id} failed with: #{e}"
  end
end
{% endhighlight %}

This means that if one job fails unexpectedly, it won't crash the event loop,
and we'll know which job it was!
