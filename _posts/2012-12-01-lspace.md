---
title: "LSpace: Dynamic scope for Ruby"
permalink: blog/lspace.html
layout: post
fuzzydate: December 2012
---

Over the last week or two I've been working on an exciting new library:
[LSpace](https://github.com/ConradIrwin/lspace).

At its simplest, LSpace is an update to Ruby's thread-local variables to bring
them kicking and screaming into the 202nd decade:

1. LSpace locals are changed only for the duration of a block. This means that
   you won't permanently clobber the value that someone else set, and that your
   value won't leak once you no-longer need it.
2. LSpace can automatically extend the notion of thread when you're using
   [eventmachine](https://github.com/eventmachine/eventmachine) or
   [celluloid](http://celluloid.io). Values in LSpace are preserved even when your code
   jumps between actors or continues after a callback.

As I'm sure the old-time-lispers are eager to point out, the first makes
LSpace an implementation of
[dynamic scoping](http://en.wikipedia.org/wiki/Dynamic_scope#Lexical_scoping_and_dynamic_scoping)
and the second exists to avoid the confusion caused by the
[upwards funarg problem](http://en.wikipedia.org/wiki/Funarg_problem#Upwards_funarg_problem).

What's it good for?
===================

LSpace is for storing secondary data about your program. For example, if you
want to make sure a string is always included in log output, you can add it to
LSpace:

{% highlight ruby %}
def log(str)
  puts "#{LSpace[:log_prefix]}: #{str}"
end

LSpace.with(:log_prefix => "example") do
  log "hello world"
end
# => example: hello world
{% endhighlight %}

I could have just passed `log_prefix` into the log method directly, but I chose not to in
order to keep the API clean. The benefits of this become more obvious in a larger example:

{% highlight ruby %}
def fetch(url)
  url = URI(url)
  log "Fetching #{url}"
  Net::HTTP.get(url)
end

def get_title(url)
  html = fetch(url)
  (Nokogiri::HTML(html) / 'title').to_s
end

LSpace.with(:log_prefix => "example") do
  get_title 'http://www.google.com'
end
{% endhighlight %}

If I didn't have LSpace (or thread locals) then I'd have had to pass
`log_prefix` as an argument to `get_title`. This works, but it's ugly:

{% highlight ruby %}
def get_title(url, log_prefix)
  html = fetch(url, log_prefix)
  (Nokogiri::HTML(html) / 'title').to_s
end
{% endhighlight %}

I don't just mean "it's ugly because it now takes two parameters", though that
certainly doesn't help. It's ugly because `get_title` shouldn't depend on how
`fetch` is implemented; in fact, `fetch` shouldn't even depend on how the logger
is implemented.

This tight coupling means that if I ever want to add a new `log` call to my
application, I'm going to have to change a lot of code to pass the `log_prefix`
all the way down to the logger. This is clearly bad for maintainability, as it's
adding a lot of extra work for the programmer.

Should I use LSpace?
====================

LSpace makes part of your context implicit. This is good because it reduces the
amount of boilerplate state-passing you need, but can be confusing if over-used
(see `this` in Javascript for perhaps the most infamous example).

We use LSpace mostly for framework-level concerns, rather than directly for
application logic. In particular it's good for:

1. Setting a logging prefix (just like in the example above). It makes logs much
   easier to read when you can associate lines that came from the same request.
2. Being able to use a particular database connection for the duration of a
   block. When we show the user their own information, we force the code to read
   from our master database so that any changes they just made will appear.
3. Maintaining state in our metrics library to enable
   [Zipkin](http://twitter.github.com/zipkin/)-style traces of which slownesses
   are caused by which others.

Other people are using similar ideas for some really cool stuff. In particular
you should look at how the reactive programming is implemented in
[meteor.js](http://docs.meteor.com/#reactivity), or why dynamic scope is used in
[Emacs lisp](http://www.gnu.org/software/emacs/emacs-paper.html#SEC18).

What else can it do?
====================

It turns out that the magic LSpace needs to implement dynamic closures (i.e.,
the magic that lets it extend thread-local variables across eventmachine
callbacks or celluloid actor calls) is pretty useful on its own.

If you're interested in doing something similar, you can add an `around_filter`
to an LSpace, and it will ensure that whenever the LSpace is re-activated, the
code is wrapped by your block.

We use this for integrating with log4r (which has support for thread-locals, but
not LSpace) and also for implementing a fallback exception handler in
eventmachine:

{% highlight ruby %}
LSpace.around_filter do |&block|
  begin
    block.call
  rescue => e
    puts "Job #{job_id} failed with: #{e}"
  end
end
{% endhighlight %}

This means that if one job fails unexpectedly, it won't crash the event loop,
and we'll know which job it was!
